# JUnit道場3

## シラバス
### 基礎編
- JUnit道場1: JUnitを書いて実行してみよう
- JUnit道場2: hamcrestを使ったアサーションを書いてみよう
- JUnit道場3: **扱いにくいクラスをモックしよう（←いまここ）**
- JUnit道場4: mockitoを使ってモックを簡単に書こう

## 事前準備
このレポジトリ https://github.com/Null-PE/JavaPlayground.git
をcloneして、EclipseでImportしてください。

## ハンズオン: IScratchをMockしてWinCalculatorをテストしよう

 - モッククラスの作成
   - IScratchを実装したMockScratchクラスを作成してください。
   - `int[][]`型のフィールド`sheet`を受け取ってコンストラクタから指定した値に
     初期化できるようにしてください。
   - `getValue(row,col)`を実装してください。 
 - テスト追加
   - MockScratchクラスを使って `check(scratch)`メソッドをテストしてください。
   - テストケース
     - 1行目が全て1の時は10を返す。
     - 3行目が全て4の時は40を返す
 
## 課題: RandomクラスをMockしてLotteryFactoryをテストしよう
- モッククラス作成
  - Randomクラスを継承したMockRandomクラスを作成してください。
  - `Iterator<Integer>`を保持するフィールド`iterator`とGetterを追加し、コンストラクタで受け取れるようにしてください。
  - `nextInt(bound)`をオーバーライドし、イテレータを一つずつ消費するようにしてください。また、`bound` が9でないときはInvalidArgumentExceptionを投げるようにしてください。
- テスト追加
  - LotteryFactoryTestクラスを作成してテストを追加してください。
  - テストケース
    - `getValue(0, 0)` の返り値が `1-9`の範囲にあること
    - `getValue(2, 2)` の返り値が `1-9`の範囲にあること
    - インスタンスの初期化時に `iterator.nextInt(9)`を９回呼び出すこと

## 宿題: テストを追加してWinCalculatorのデバッグしよう
WinCalculatorクラスには多数のバグを仕込んでいます。
バグを見つけたらテスト駆動開発で修正してみましょう。

1. バグを再現するテストを追加し、テストが失敗することを確認する。
2. テストが通るようにデバッグする
3. テストコードの重複を取り除く

どのようなテストケースを書けば効率よくバグを発見できるか考えてみましょう。
（分からなかったら [コラム2](#コラム2: 仕様をテストに分解する)を読んでみてください)


## コラム1： Mockとは何か

モックはユニットテストを書くために、一部のオブジェクトをモックオブジェクトに
差し替えて挙動を制御する事です。

モックが必要な場合は主に以下の２パターンがあります。

1. オブジェクトのインスタンスがテスト時に生成できない（または期待する内部状態にできない）とき
  - 例：コンストラクタがpublicになっていない、
  - 例：コンストラクタの呼び出し結果が不定
    - 外部アクセスする
    - 現在時刻をフィールドにセットする
    - ランダムな値をフィールドにセットする
  - 例：特定のフィールドの初期化を制御したい
2. オブジェクトのあるメソッドがテスト時に呼び出せない時（または期待する値を返せない）とき
  - 例：メソッドの呼び出し結果が不定
  - 例：メソッドの実行に時間がかかる
  - 例：返り値を制御したい

### モックの方式
#### サブクラス方式 (mockito)
モックしたいクラスのサブクラス（あるいはインターフェースの実装）を作成し、
コンストラクタや、メソッドをオーバーライドすることで挙動を制御します。

- 利点: 言語の枠組みの中で行うため、挙動が予測しやすい
- 欠点: `static`や`final`, `private`がついているとモックできない。`new`に介入できない。 

#### クラスローダー方式 (jmockit, Powermock)
テスト実行時のクラスローダを制御し、特定のオブジェクトのクラスファイルを差し替えることで
挙動を制御します。

- 利点: `static`や`final`や`private`や`new`もモックできる
- 欠点: `new`や`static`を書き換えると想定外の場所まで挙動が変わり、テストが不安定になる。動作が遅い。

## コラム2: 仕様をテストに分解する
これまでの課題では仕様が細かく細分化されていて、仕様とテストがほぼ1:1対応していました。
しかし、実際の開発では仕様は抽象的に与えられて、具体的なテストケースをどう選んで良いのか
分からないこともあるでしょう。

今回の課題を例にテストケースの選び方を説明します。

今回のWinCalculatorの仕様は以下のように書かれています。
>  * 仕様1: 縦、よこ、斜めで同じ数字が揃う（ビンゴ）と、(数字) x 10円があたります。
>  * 仕様2: ビンゴ数複数個ある場合、それぞれのあたり金額の積があたります。

入力は3x3の升目に1-9の数字が書かれたものなので、
入力パターン数を全通り調べると、 9の9乗 = 387,420,489通りあります。
全通り検査することは不可能なので、
有用なテストケースを抜き出す必要があります。

JUnitでテストケースを書く場合、実装をみながらテストを書くことになるので
テストはホワイトボックステストにしてよいです。
実装をみると、以下の二つの機能がある事がわかります。

1. 縦・横・斜めの各ビンゴを検出する機能
2. ビンゴが複数個あった場合にあたり金額を乗算する機能

これはほぼ仕様の単なる言い換えですが、
ここから、テストパターンの分類として、ビンゴの数で分けたら良さそうだ
という事がわかります。

ビンゴの数のパターンは以下の通りです。
- ビンゴの数が0
- ビンゴの数が1
- ビンゴの数が2
- ビンゴの数が3
- ビンゴの数が4
- ビンゴの数が5
- ビンゴの数が6
- ビンゴの数が8

まだパターン数が多いので絞り込みます。
実装をみると、ビンゴを検出するたびにあたり金額を更新しています。
そのため、ビンゴの数が２つだとバグらないが、３つだとバグるというケースは
起こらないと考えられます。

したがって以下の３つを考えましょう
- ビンゴの数が0
- ビンゴの数が1
- ビンゴの数が2

### ビンゴの数が0のとき
このパターンはどのテストデータでもプログラムの挙動が変わらないはず
なので１ケースだけテストすれば十分です。

### ビンゴの数が1のとき
ビンゴは行3パターン,　列3パターン, 斜め2パターンあります。
したがって８パターンテストすれば良さそうですが、
実装を加味するともう少し減らせます。

横ビンゴの判定ロジックはfor文で書かれています。

```java
for( int row = 0; row < 3; row++) {
    int value = scratch.getValue(row, 0);
    if( value == scratch.getValue(row, 1) && value == scratch.getValue(row, 2)) {
        score *= value * 10;
    }
}
```

行インデックス`row`は0-2を動くのですが、その具体的な値に依存した
コードにはなっていません。したがって、境界である、0と2のみテストすれば
良いです。（境界値をチェックするのはループ回数にバグがないかを確認するためです）

一方で斜めビンゴの判定ロジックはfor文で書かれていないので
両方のパターンをテストする必要があります。

テストパターンを減らすと以下の６パターンになります。
- 1行目、3行目
- 1列目、3列目
- 斜め２パターン

各パターンにつき１つのテストケースを用意すれば良いでしょう。

### ビンゴが２つのとき
このパターン数を列挙してみましょう。
ビンゴは合計８種類あるので、全パターン数は 8 * 7 / 2 = 28通りあります。
全通り検査するには多いので実装をみながらパターンを絞ります。

実装を読むと、乗算処理は、`score`変数の更新によって実装されている
ので、一つ目のビンゴは何であっても挙動が変わらないはずです。 

したがって２つ目のビンゴのみ各パターン検査すればよく、
以下の４パターンになります。
- 行ビンゴ x 行ビンゴ
- 行ビンゴ x 列ビンゴ
- 行ビンゴ x 斜め下ビンゴ
- 行ビンゴ x 斜め上ビンゴ

また、今回は行ビンゴ、列ビンゴも１パターンのみ検査すれば十分です。
なぜなら、ビンゴが１つの時のケースで各ビンゴの判定ロジックがただしい
ことは確認されているからです。

### まとめ
ここまででまとめると以下の11ケースをテストすれば良さそうです。

- ビンゴ数0: 1ケース
- ビンゴ数1: 6ケース
  - 行ビンゴ: 1,3行名
  - 列ビンゴ: 1,3列目
  - 斜めビンゴ: 斜め下、斜め上
- ビンゴ数2: 4ケース
  - 行 x 行
  - 行 x 列
  - 行 x 斜め下
  - 行 x 斜め上

さて、これで概ね十分なのですが、
追加で最大ケースのテストをやっておくと良いでしょう。
今回の最大ケースは、全ての数字が9の場合で、
その時のあたり金額は4304兆円なので、
数値のオーバーフローバグが発生する場合があります。